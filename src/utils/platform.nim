## Platform-Specific Enhancements for Nim TestKit
##
## This module provides enhanced platform support including:
## - Better Windows support with PowerShell scripts
## - macOS-specific test templates
## - Mobile platform testing support
## - WebAssembly test support

import std/[os, strutils, strformat, sequtils, tables]
import ../config/config

type
  Platform* = enum
    Windows = "windows"
    macOS = "macos"
    Linux = "linux"
    iOS = "ios"
    Android = "android"
    WebAssembly = "wasm"

  PlatformConfig* = object
    target*: Platform
    enabled*: bool
    scriptExtension*: string
    shellCommand*: string
    testTemplates*: Table[string, string]
    buildFlags*: seq[string]
    runFlags*: seq[string]

  CrossPlatformConfig* = object
    platforms*: seq[PlatformConfig]
    defaultPlatform*: Platform
    sharedTemplates*: Table[string, string]

proc detectPlatform*(): Platform =
  ## Detect the current platform
  when defined(windows):
    result = Windows
  elif defined(macosx):
    result = macOS
  elif defined(linux):
    result = Linux
  elif defined(js):
    result = WebAssembly
  else:
    result = Linux  # Default fallback

proc createDefaultPlatformConfig*(): CrossPlatformConfig =
  ## Create default platform configuration
  result.defaultPlatform = detectPlatform()
  result.platforms = @[]
  
  # Windows configuration
  result.platforms.add(PlatformConfig(
    target: Windows,
    enabled: true,
    scriptExtension: ".ps1",
    shellCommand: "powershell -ExecutionPolicy Bypass -File",
    buildFlags: @["-d:windows", "--os:windows"],
    runFlags: @["--verbosity:0"]
  ))
  
  # macOS configuration
  result.platforms.add(PlatformConfig(
    target: macOS,
    enabled: true,
    scriptExtension: ".sh",
    shellCommand: "bash",
    buildFlags: @["-d:macosx", "--os:macosx"],
    runFlags: @["--verbosity:0"]
  ))
  
  # Linux configuration
  result.platforms.add(PlatformConfig(
    target: Linux,
    enabled: true,
    scriptExtension: ".sh",
    shellCommand: "bash",
    buildFlags: @["-d:linux", "--os:linux"],
    runFlags: @["--verbosity:0"]
  ))
  
  # iOS configuration
  result.platforms.add(PlatformConfig(
    target: iOS,
    enabled: false,
    scriptExtension: ".sh",
    shellCommand: "bash",
    buildFlags: @["-d:ios", "--os:ios", "--cpu:arm64"],
    runFlags: @["--simulator"]
  ))
  
  # Android configuration
  result.platforms.add(PlatformConfig(
    target: Android,
    enabled: false,
    scriptExtension: ".sh",
    shellCommand: "bash",
    buildFlags: @["-d:android", "--os:android", "--cpu:arm64"],
    runFlags: @["--emulator"]
  ))
  
  # WebAssembly configuration
  result.platforms.add(PlatformConfig(
    target: WebAssembly,
    enabled: false,
    scriptExtension: ".js",
    shellCommand: "node",
    buildFlags: @["-d:js", "--backend:js"],
    runFlags: @["--nodejs"]
  ))

proc generateWindowsPowerShellScript*(scriptName: string, commands: seq[string]): string =
  ## Generate PowerShell script for Windows
  result = fmt"""# {scriptName} - Windows PowerShell Script
# Generated by Nim TestKit

param(
    [string]$Target = ".",
    [switch]$Verbose,
    [switch]$DryRun
)

# Set error action preference
$ErrorActionPreference = "Stop"

# Enable verbose output if requested
if ($Verbose) {{
    $VerbosePreference = "Continue"
}}

function Write-Info {{
    param([string]$Message)
    Write-Host "[INFO] $Message" -ForegroundColor Green
}}

function Write-Warning {{
    param([string]$Message)
    Write-Host "[WARN] $Message" -ForegroundColor Yellow
}}

function Write-Error {{
    param([string]$Message)
    Write-Host "[ERROR] $Message" -ForegroundColor Red
}}

try {{
    Write-Info "Starting {scriptName}..."
    Write-Info "Target: $Target"
    
    # Check prerequisites
    if (-not (Get-Command nim -ErrorAction SilentlyContinue)) {{
        throw "Nim compiler not found. Please install Nim and ensure it's in your PATH."
    }}
    
    if (-not (Get-Command nimble -ErrorAction SilentlyContinue)) {{
        throw "Nimble package manager not found. Please install Nimble."
    }}
    
    # Execute commands
{commands.mapIt("    " & it).join("\n")}
    
    Write-Info "{scriptName} completed successfully!"
    
}} catch {{
    Write-Error "Failed to execute {scriptName}: $($_.Exception.Message)"
    exit 1
}}
"""

proc generateMacOSTestTemplate*(moduleName: string): string =
  ## Generate macOS-specific test template
  result = fmt"""
import unittest, os, osproc, strutils
import {moduleName}

# macOS-specific imports and utilities
when defined(macosx):
  import posix
  
  proc getSystemVersion(): string =
    ## Get macOS system version
    let (output, exitCode) = execCmdEx("sw_vers -productVersion")
    if exitCode == 0:
      result = output.strip()
    else:
      result = "unknown"
  
  proc isRunningOnM1(): bool =
    ## Check if running on Apple M1/M2 chip
    let (output, exitCode) = execCmdEx("uname -m")
    result = exitCode == 0 and "arm64" in output
  
  proc getAvailableMemory(): int =
    ## Get available memory in bytes
    let (output, exitCode) = execCmdEx("sysctl -n hw.memsize")
    if exitCode == 0:
      try:
        result = parseInt(output.strip())
      except ValueError:
        result = 0
    else:
      result = 0

suite "macOS Platform Tests for {moduleName}":
  
  setup:
    echo "macOS System Information:"
    when defined(macosx):
      echo "  Version: ", getSystemVersion()
      echo "  Architecture: ", if isRunningOnM1(): "Apple Silicon" else: "Intel"
      echo "  Available Memory: ", getAvailableMemory() div (1024 * 1024), " MB"
  
  test "{moduleName} macOS file system integration":
    when defined(macosx):
      # Test HFS+ case sensitivity behavior
      let testDir = "/tmp/nimtestkit_case_test"
      createDir(testDir)
      defer: removeDir(testDir)
      
      let file1 = testDir / "TestFile.txt"
      let file2 = testDir / "testfile.txt"
      
      writeFile(file1, "content1")
      
      # On case-sensitive file systems, these should be different files
      # On case-insensitive file systems, they should be the same
      let areCaseSensitive = not fileExists(file2)
      
      if areCaseSensitive:
        writeFile(file2, "content2")
        check readFile(file1) != readFile(file2)
      else:
        check readFile(file1) == "content1"
  
  test "{moduleName} macOS bundle support":
    when defined(macosx):
      # Test application bundle structure
      let bundlePath = "/tmp/TestApp.app"
      let contentsDir = bundlePath / "Contents"
      let macOSDir = contentsDir / "MacOS"
      let resourcesDir = contentsDir / "Resources"
      
      createDir(macOSDir)
      createDir(resourcesDir)
      defer: removeDir(bundlePath)
      
      # Create Info.plist
      let infoPlist = contentsDir / "Info.plist"
      let plistContent = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" &
        "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n" &
        "<plist version=\"1.0\">\n" &
        "<dict>\n" &
        "    <key>CFBundleIdentifier</key>\n" &
        "    <string>com.example.testapp</string>\n" &
        "    <key>CFBundleName</key>\n" &
        "    <string>TestApp</string>\n" &
        "</dict>\n" &
        "</plist>"
      writeFile(infoPlist, plistContent)
      
      check fileExists(infoPlist)
      check dirExists(macOSDir)
      check dirExists(resourcesDir)
  
  test "{moduleName} macOS performance characteristics":
    when defined(macosx):
      # Test performance on different architectures
      let iterations = if isRunningOnM1(): 10000 else: 5000
      
      let startTime = cpuTime()
      for i in 0..<iterations:
        discard {moduleName}.performOperation()
      let endTime = cpuTime()
      
      let avgTime = (endTime - startTime) / iterations.float
      echo fmt"Average operation time: {{avgTime * 1000:.3f}}ms"
      
      # M1 Macs should generally be faster
      let expectedMaxTime = if isRunningOnM1(): 0.001 else: 0.002
      check avgTime < expectedMaxTime
"""

proc generateMobileTestTemplate*(moduleName: string, platform: Platform): string =
  ## Generate mobile platform test template
  let platformName = case platform:
    of iOS: "iOS"
    of Android: "Android"
    else: "Mobile"
  
  result = fmt"""
import unittest, asyncdispatch, json
import {moduleName}

# Mobile-specific testing utilities
when defined(ios) or defined(android):
  
  proc isRunningOnDevice(): bool =
    ## Check if running on actual device vs simulator/emulator
    when defined(ios):
      # iOS device detection logic
      result = not defined(simulator)
    elif defined(android):
      # Android device detection logic
      result = not defined(emulator)
    else:
      result = false
  
  proc getDeviceInfo(): tuple[name: string, version: string, memory: int] =
    ## Get device information
    when defined(ios):
      result = ("iOS Device", "15.0", 4096)  # Placeholder
    elif defined(android):
      result = ("Android Device", "12.0", 8192)  # Placeholder
    else:
      result = ("Unknown", "0.0", 0)
  
  proc testTouchInput() =
    ## Simulate touch input testing
    echo "Testing touch input simulation"
    # Implement touch event simulation
  
  proc testSensorInput() =
    ## Test sensor input (accelerometer, gyroscope, etc.)
    echo "Testing sensor input"
    # Implement sensor testing
  
  proc testNetworkConnectivity() =
    ## Test network connectivity scenarios
    echo "Testing network connectivity"
    # Test offline/online scenarios

suite "{platformName} Platform Tests for {moduleName}":
  
  setup:
    when defined(ios) or defined(android):
      let deviceInfo = getDeviceInfo()
      echo fmt"{platformName} Device Information:"
      echo fmt"  Name: {{deviceInfo.name}}"
      echo fmt"  Version: {{deviceInfo.version}}"
      echo fmt"  Memory: {{deviceInfo.memory}} MB"
      echo fmt"  Running on device: {{isRunningOnDevice()}}"
  
  test "{moduleName} {platformName} memory management":
    when defined(ios) or defined(android):
      # Test memory usage on mobile devices
      let memBefore = getOccupiedMem()
      
      # Perform memory-intensive operation
      var data: seq[string] = @[]
      for i in 0..<1000:
        data.add("test data " & $i)
      
      let memAfter = getOccupiedMem()
      let memUsed = memAfter - memBefore
      
      # Mobile devices have limited memory
      check memUsed < 50_000_000  # Should use less than 50MB
      
      # Clean up
      data = @[]
      GC_fullCollect()
  
  test "{moduleName} {platformName} UI responsiveness":
    when defined(ios) or defined(android):
      # Test UI thread responsiveness
      proc longRunningOperation() {{.async.}} =
        await sleepAsync(100)  # Simulate work
      
      let startTime = cpuTime()
      waitFor longRunningOperation()
      let endTime = cpuTime()
      
      # Operations should not block UI thread
      check (endTime - startTime) < 0.2  # Should complete quickly
  
  test "{moduleName} {platformName} power efficiency":
    when defined(ios) or defined(android):
      # Test power-efficient operations
      let startTime = cpuTime()
      
      # Perform operations that should be power-efficient
      for i in 0..<100:
        discard {moduleName}.efficientOperation()
      
      let endTime = cpuTime()
      let totalTime = endTime - startTime
      
      # Should complete efficiently
      check totalTime < 1.0  # Should complete in under 1 second
  
  test "{moduleName} {platformName} input handling":
    when defined(ios) or defined(android):
      # Test mobile-specific input handling
      testTouchInput()
      testSensorInput()
      
      # Verify input processing
      check {moduleName}.canHandleTouchInput()
      check {moduleName}.canHandleSensorInput()
  
  test "{moduleName} {platformName} network scenarios":
    when defined(ios) or defined(android):
      # Test network connectivity scenarios
      testNetworkConnectivity()
      
      # Test offline functionality
      check {moduleName}.canWorkOffline()
      
      # Test data synchronization
      check {moduleName}.canSyncData()
"""

proc generateWebAssemblyTestTemplate*(moduleName: string): string =
  ## Generate WebAssembly-specific test template
  result = fmt"""
import unittest, asyncjs, dom, jsconsole
import {moduleName}

# WebAssembly-specific testing utilities
when defined(js):
  
  proc getBrowserInfo(): tuple[name: string, version: string] =
    ## Get browser information
    let userAgent = window.navigator.userAgent
    if "Chrome" in userAgent:
      result = ("Chrome", "latest")
    elif "Firefox" in userAgent:
      result = ("Firefox", "latest")
    elif "Safari" in userAgent:
      result = ("Safari", "latest")
    else:
      result = ("Unknown", "unknown")
  
  proc testDOMManipulation() =
    ## Test DOM manipulation capabilities
    let testDiv = document.createElement("div")
    testDiv.id = "test-element"
    testDiv.innerHTML = "Test Content"
    document.body.appendChild(testDiv)
    
    let retrieved = document.getElementById("test-element")
    doAssert retrieved != nil
    doAssert retrieved.innerHTML == "Test Content"
    
    document.body.removeChild(testDiv)
  
  proc testAsyncJavaScript() {{.async.}} =
    ## Test async JavaScript interop
    let promise = newPromise() do (resolve: proc(value: JsObject)):
      discard setTimeout(proc() = resolve(toJs("completed")), 100)
    
    let result = await promise
    doAssert result.to(string) == "completed"
  
  proc testMemoryManagement() =
    ## Test WebAssembly memory management
    let memBefore = getOccupiedMem()
    
    # Create and manipulate data
    var data: seq[int] = @[]
    for i in 0..<10000:
      data.add(i)
    
    let memAfter = getOccupiedMem()
    let memUsed = memAfter - memBefore
    
    # Clean up
    data = @[]
    GC_fullCollect()
    
    console.log(fmt"Memory used: {{memUsed}} bytes")

suite "WebAssembly Platform Tests for {moduleName}":
  
  setup:
    when defined(js):
      let browserInfo = getBrowserInfo()
      console.log(fmt"Browser: {{browserInfo.name}} {{browserInfo.version}}")
      console.log("WebAssembly support:", typeof(window.WebAssembly) != "undefined")
  
  test "{moduleName} WebAssembly DOM integration":
    when defined(js):
      testDOMManipulation()
      check {moduleName}.canManipulateDOM()
  
  test "{moduleName} WebAssembly async operations":
    when defined(js):
      proc testAsync() {{.async.}} =
        await testAsyncJavaScript()
        check {moduleName}.supportsAsync()
      
      waitFor testAsync()
  
  test "{moduleName} WebAssembly performance":
    when defined(js):
      let startTime = now()
      
      # Perform computation-heavy operations
      for i in 0..<1000:
        discard {moduleName}.computeHeavyOperation(i)
      
      let endTime = now()
      let duration = endTime - startTime
      
      console.log(fmt"Duration: {{duration}}ms")
      check duration < 1000  # Should complete in under 1 second
  
  test "{moduleName} WebAssembly memory limits":
    when defined(js):
      testMemoryManagement()
      check {moduleName}.managesMemoryEfficiently()
  
  test "{moduleName} WebAssembly JavaScript interop":
    when defined(js):
      # Test data exchange with JavaScript
      let jsData = toJs({{"key": "value", "number": 42}})
      let nimData = {moduleName}.processJavaScriptData(jsData)
      
      check nimData.isValid()
      check nimData.hasKey("processed")
"""

proc generatePlatformSpecificScript*(platform: Platform, scriptType: string, commands: seq[string]): string =
  ## Generate platform-specific script
  case platform:
  of Windows:
    result = generateWindowsPowerShellScript(scriptType, commands)
  of macOS, Linux:
    result = fmt"""#!/bin/bash
# {scriptType} - {platform} Shell Script
# Generated by Nim TestKit

set -e  # Exit on error

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

info() {{
    echo -e "${{GREEN}}[INFO]${{NC}} $1"
}}

warn() {{
    echo -e "${{YELLOW}}[WARN]${{NC}} $1"
}}

error() {{
    echo -e "${{RED}}[ERROR]${{NC}} $1"
}}

# Check prerequisites
if ! command -v nim &> /dev/null; then
    error "Nim compiler not found. Please install Nim."
    exit 1
fi

if ! command -v nimble &> /dev/null; then
    error "Nimble package manager not found."
    exit 1
fi

info "Starting {scriptType}..."

# Execute commands
{commands.join("\n")}

info "{scriptType} completed successfully!"
"""
  else:
    result = fmt"# Unsupported platform: {platform}"

proc createPlatformTemplates*(config: CrossPlatformConfig): Table[string, string] =
  ## Create platform-specific test templates
  result = initTable[string, string]()
  
  for platformConfig in config.platforms:
    if not platformConfig.enabled:
      continue
    
    case platformConfig.target:
    of macOS:
      result["macos_test_template"] = generateMacOSTestTemplate("$MODULE")
    of iOS:
      result["ios_test_template"] = generateMobileTestTemplate("$MODULE", iOS)
    of Android:
      result["android_test_template"] = generateMobileTestTemplate("$MODULE", Android)
    of WebAssembly:
      result["wasm_test_template"] = generateWebAssemblyTestTemplate("$MODULE")
    of Windows:
      result["windows_test_template"] = """
import unittest, os, winlean
import $MODULE

suite "Windows Platform Tests for $MODULE":
  test "$MODULE Windows file system":
    # Test Windows-specific file system behavior
    check true
"""
    of Linux:
      result["linux_test_template"] = """
import unittest, posix
import $MODULE

suite "Linux Platform Tests for $MODULE":
  test "$MODULE Linux system integration":
    # Test Linux-specific system integration
    check true
"""

when isMainModule:
  echo "Platform Support Module"
  echo "Detected platform: ", detectPlatform()
  
  let config = createDefaultPlatformConfig()
  echo "Supported platforms: ", config.platforms.mapIt(it.target)