# Integration test generation for nim-testkit
# Zero external dependencies - uses only Nim stdlib

import std/[os, strutils, strformat]
import ../core/types

type
  IntegrationTestTemplate* = object
    testName*: string
    modules*: seq[string]  # Modules being integrated
    category*: TestCategory
    setupCode*: string
    teardownCode*: string
    scenarios*: seq[IntegrationScenario]

  IntegrationScenario* = object
    name*: string
    description*: string
    steps*: seq[TestStep]
    expectedOutcome*: string

  TestStep* = object
    action*: string
    validation*: string

proc generateIntegrationTest*(tmpl: IntegrationTestTemplate): string =
  ## Generate an integration test file from template
  result = fmt"# Integration tests for {tmpl.testName}" & "\n"
  result.add "# Generated by nim-testkit\n\n"
  
  # Add imports for all modules
  for module in tmpl.modules:
    result.add fmt"import {module}" & "\n"
  result.add "\n"
  
  # Add test suite
  result.add fmt"""suite "{tmpl.testName} integration tests":""" & "\n"
  
  # Add setup
  if tmpl.setupCode.len > 0:
    result.add "  setup:\n"
    for line in tmpl.setupCode.splitLines():
      if line.len > 0:
        result.add "    " & line & "\n"
    result.add "\n"
  
  # Add teardown
  if tmpl.teardownCode.len > 0:
    result.add "  teardown:\n"
    for line in tmpl.teardownCode.splitLines():
      if line.len > 0:
        result.add "    " & line & "\n"
    result.add "\n"
  
  # Add integration scenarios
  for scenario in tmpl.scenarios:
    result.add fmt"""  test "{scenario.name}":""" & "\n"
    if scenario.description.len > 0:
      result.add fmt"    # {scenario.description}" & "\n"
    result.add "\n"
    
    # Add test steps
    for i, step in scenario.steps:
      result.add fmt"    # Step {i+1}: {step.action}" & "\n"
      for line in step.action.splitLines():
        if line.len > 0:
          result.add "    " & line & "\n"
      
      if step.validation.len > 0:
        result.add "\n    # Validate\n"
        for line in step.validation.splitLines():
          if line.len > 0:
            result.add "    " & line & "\n"
      result.add "\n"
    
    # Add expected outcome
    if scenario.expectedOutcome.len > 0:
      result.add fmt"    # Expected outcome: {scenario.expectedOutcome}" & "\n"
    result.add "\n"

proc generateHALIntegrationTest*(halModule: string, driverModule: string): IntegrationTestTemplate =
  ## Generate HAL layer integration test
  result.testName = fmt"HAL-{driverModule}"
  result.modules = @[fmt"kernel/hal/{halModule}", fmt"drivers/{driverModule}"]
  result.category = tcIntegration
  
  result.setupCode = """
# Initialize HAL
let hal = initHAL()

# Initialize driver
let driver = initDriver()"""
  
  result.teardownCode = """
# Cleanup
driver.cleanup()
hal.shutdown()"""
  
  result.scenarios = @[
    IntegrationScenario(
      name: "Driver registration and initialization",
      description: "Test driver can register with HAL and initialize",
      steps: @[
        TestStep(
          action: "let registered = hal.registerDriver(driver)",
          validation: "check registered == true"
        ),
        TestStep(
          action: "let initialized = driver.initialize(hal)",
          validation: """check initialized == true
check driver.getStatus() == DriverStatus.Ready"""
        )
      ],
      expectedOutcome: "Driver successfully integrated with HAL"
    ),
    IntegrationScenario(
      name: "HAL-Driver communication",
      description: "Test bidirectional communication",
      steps: @[
        TestStep(
          action: """hal.registerDriver(driver)
driver.initialize(hal)
let request = createRequest(READ, 0x1000, 1024)
let response = hal.sendRequest(driver, request)""",
          validation: """check response.status == Success
check response.data.len == 1024"""
        )
      ],
      expectedOutcome: "Successful data exchange"
    )
  ]

proc generateWASIIntegrationTest*(wasiModule: string, kernelModule: string): IntegrationTestTemplate =
  ## Generate WASI runtime integration test
  result.testName = fmt"WASI-{kernelModule}"
  result.modules = @[fmt"wasi/{wasiModule}", fmt"kernel/{kernelModule}"]
  result.category = tcIntegration
  
  result.setupCode = """
# Initialize WASI runtime
let wasi = initWASI()

# Initialize kernel module
let kernelMod = initKernelModule()

# Connect them
wasi.registerKernelModule(kernelMod)"""
  
  result.scenarios = @[
    IntegrationScenario(
      name: "WASI system call routing",
      description: "Test WASI calls are routed to kernel correctly",
      steps: @[
        TestStep(
          action: """# Make WASI call
let fd = wasi.openFile("/test.txt", O_RDONLY)""",
          validation: """check fd >= 0
check kernelMod.getLastSyscall() == SyscallType.Open"""
        ),
        TestStep(
          action: """# Read from file
var buffer: array[256, byte]
let bytesRead = wasi.read(fd, buffer)""",
          validation: """check bytesRead >= 0
check kernelMod.getLastSyscall() == SyscallType.Read"""
        )
      ],
      expectedOutcome: "WASI calls properly routed to kernel"
    )
  ]

proc generatePlatformDriverTest*(platform: string, driver: string): IntegrationTestTemplate =
  ## Generate platform-specific driver integration test
  result.testName = fmt"{platform}-{driver}"
  result.modules = @[fmt"platforms/{platform}/platform", fmt"platforms/{platform}/drivers/{driver}"]
  result.category = tcIntegration
  
  result.setupCode = fmt"""
# Platform-specific setup for {platform}
let platform = init{platform.capitalizeAscii}Platform()
let driver = init{driver.capitalizeAscii}Driver()

# Register driver with platform
platform.registerDriver(driver)"""
  
  result.scenarios = @[
    IntegrationScenario(
      name: "Platform-specific driver initialization",
      description: fmt"Test {driver} driver on {platform} platform",
      steps: @[
        TestStep(
          action: "let initialized = driver.platformInit(platform)",
          validation: """check initialized == true
check driver.isPlatformCompatible(platform)"""
        ),
        TestStep(
          action: """# Test platform-specific features
let feature = driver.getPlatformFeature("special_feature")""",
          validation: "check feature != nil"
        )
      ],
      expectedOutcome: fmt"Driver works correctly on {platform}"
    )
  ]

proc saveIntegrationTest*(tmpl: IntegrationTestTemplate, outputDir: string) =
  ## Save generated integration test
  let categoryDir = outputDir / "spec" / $tmpl.category
  createDir(categoryDir)
  
  let filename = categoryDir / fmt"test_{tmpl.testName.replace('-', '_')}_integration.nim"
  let content = generateIntegrationTest(tmpl)
  writeFile(filename, content)
  
  echo fmt"Generated integration test: {filename}"

# Helper to identify integration points
proc findIntegrationPoints*(srcDir: string): seq[tuple[module1, module2: string]] =
  ## Find modules that should be integration tested together
  result = @[]
  
  # Look for import relationships
  for file in walkDirRec(srcDir):
    if file.endsWith(".nim"):
      let content = readFile(file)
      let moduleName = file.extractFilename().replace(".nim", "")
      
      # Find imports
      for line in content.splitLines():
        if line.startsWith("import ") or line.startsWith("from "):
          # Extract imported module
          let importedModule = line.split(" ")[1].strip()
          if not importedModule.startsWith("std/"):
            result.add((moduleName, importedModule))